<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
// <auto-generated>
using System;

namespace UnionTypes
{
    /// <summary>
    /// Base class for all union classes.
    /// </summary>
    public abstract class Union
    {
        /// <summary>
        /// Gets or sets the type of the value in the union.
        /// </summary>
        public Type Type { get; protected set; }

        /// <summary>
        /// Gets the value stored in the union.
        /// </summary>
        /// <returns>The value stored in the union. Null if no value was found.</returns>
        public abstract object Get();
    }

<# for (int i = 2; i <= 16; i++) { string[] generics = CreateGenericNames(i); string name = $"Union<{string.Join(", ", generics)}>"; #>
    /// <summary>
    /// Union type.
    /// </summary>
    public class <#= name #> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{<#= string.Join(", ", generics) #>}"/> class.
        /// </summary>
        public Union()
        {
        }

<# for (int j = 0; j < i; j++) { string generic = generics[j]; string var = $"v{j+1}";#>
        private <#= generic #> <#= var #>;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{<#= string.Join(", ", generics) #>}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(<#= generic #> value)
        {
            Type = typeof(<#= generic #>);
            <#= var #> = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{<#= string.Join(", ", generics) #>}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator <#= name #>(<#= generic #> value)
            => new <#= name #>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out <#= generic #> value)
        {
            if (Type == typeof(<#= generic #>))
            {
                value = <#= var #>;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void Set(<#= generic #> value)
        {
            Type = typeof(<#= generic #>);
<# for (int k = 0; k <= j; k++) {
    if (k == j)
    {
#>
            <#= var #> = value;
<#
    }
    else
    {
#>
            v<#= k+1 #> = default;
<#
    }
#>
<# } #>
        }

<# } #>
        /// <inheritdoc/>
        public override object Get()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
<# for (int j = 1; j <= i; j++) { #>
            else if (Type == typeof(T<#= j #>))
            {
                return v<#= j #>;
            }
<# } #>

            return null;
        }
    }

<# } #>
}

<#+
private string[] CreateGenericNames(int n)
{
    string[] genericNames = new string[n];
    for (int i = 0; i < n; i++) {
        genericNames[i] = $"T{i+1}";
    }
    return genericNames;
}
#>