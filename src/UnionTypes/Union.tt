<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<# int cardinality = 16; #>
// <auto-generated>
using System;

namespace UnionTypes
{
    /// <summary>
    /// Base class for all union classes.
    /// </summary>
    public abstract class Union
    {
        /// <summary>
        /// Gets or sets the type of the value in the union.
        /// </summary>
        public Type Type { get; protected set; }

        /// <summary>
        /// Gets the possible types in the union.
        /// </summary>
        public abstract Type[] Types { get; }

        /// <summary>
        /// Gets the value stored in the union.
        /// </summary>
        /// <returns>The value stored in the union. Null if no value was found.</returns>
        public abstract object GetValue();

        /// <summary>
        /// Clears the value kept in the union.
        /// </summary>
        public abstract void Clear();
    }

<# for (int i = 2; i <= cardinality; i++) { string[] generics = CreateGenericNames(i); string name = CreateName(generics); #>
    /// <summary>
    /// A union type.
    /// </summary>
<# foreach (string generic in generics) { #>
    /// <typeparam name="<#= generic #>">A possible type of the union.</typeparam>
<# } #>
    public class <#= name #> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{<#= string.Join(", ", generics) #>}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { <#= string.Join(", ", generics.Select(x => $"typeof({x})")) #> };

<# for (int j = 0; j < i; j++) { string generic = generics[j]; string var = $"v{j+1}";#>
        private <#= generic #> <#= var #>;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{<#= string.Join(", ", generics) #>}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(<#= generic #> value)
        {
            Type = typeof(<#= generic #>);
            <#= var #> = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="<#= CreateCommentName(generics) #>"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator <#= name #>(<#= generic #> value)
            => new <#= name #>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out <#= generic #> value)
        {
            if (Type == typeof(<#= generic #>))
            {
                value = <#= var #>;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="<#= CreateCommentName(generics) #>"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator <#= generic #>(<#= name #> union)
        {
            if (union.Match(out <#= generic #> value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(<#= generic #> value)
        {
            Type = typeof(<#= generic #>);
<# for (int k = 0; k < i; k++) {
    if (k == j)
    {
#>
            <#= var #> = value;
<# } else { #>
            v<#= k + 1 #> = default;
<# } #>
<# } #>
        }
<# } #>

        /// <inheritdoc/>
        public override object GetValue()
        {
<# for (int j = 1; j <= i; j++) { #>
            if (Type == typeof(T<#= j #>)) return v<#= j #>;
<# } #>
            return null;
        }

        /// <inheritdoc/>
        public override void Clear()
        {
            Type = null;
<# for (int j = 1; j <= i; j++) { #>
            v<#= j #> = default;
<# } #>
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is <#= name #> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(<#= name #> other)
        {
            if (Type == other.Type)
            {
<# for (int j = 1; j <= i; j++) { #>
                if (Type == typeof(T<#= j #>)) return (v<#= j #> == null && other.v<#= j #> == null) || v<#= j #>.Equals(other.v<#= j #>);
<# } #>
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

<# for (int j = 1; j <= i; j++) { #>
            if (Type == typeof(T<#= j #>)) return v<#= j #> == null ? baseHash * <#= 2 + j #> : v<#= j #>.GetHashCode() * baseHash * <#= 2 + j #>;
<# } #>
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
<# for (int j = 1; j <= i; j++) { #>
            if (Type == typeof(T<#= j #>)) return v<#= j #> == null ? string.Empty : v<#= j #>.ToString();
<# } #>
            return string.Empty;
        }
    }
<# } #>
}
<#+
private string[] CreateGenericNames(int n)
{
    string[] genericNames = new string[n];
    for (int i = 0; i < n; i++) {
        genericNames[i] = $"T{i+1}";
    }
    return genericNames;
}

private string CreateName(IEnumerable<string> generics)
    => $"Union<{string.Join(", ", generics)}>";

private string CreateCommentName(IEnumerable<string> generics)
    => $"Union{{{string.Join(", ", generics)}}}";
#>