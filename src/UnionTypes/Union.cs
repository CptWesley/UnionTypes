// <auto-generated>
using System;

namespace UnionTypes
{
    /// <summary>
    /// Base class for all union classes.
    /// </summary>
    public abstract class Union
    {
        /// <summary>
        /// Gets or sets the type of the value in the union.
        /// </summary>
        public Type Type { get; protected set; }

        /// <summary>
        /// Gets the possible types in the union.
        /// </summary>
        public abstract Type[] Types { get; }

        /// <summary>
        /// Gets the value stored in the union.
        /// </summary>
        /// <returns>The value stored in the union. Null if no value was found.</returns>
        public abstract object GetValue();
    }

    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    public class Union<T1, T2> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2>(T1 value)
            => new Union<T1, T2>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2>(T2 value)
            => new Union<T1, T2>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3>(T1 value)
            => new Union<T1, T2, T3>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3>(T2 value)
            => new Union<T1, T2, T3>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3>(T3 value)
            => new Union<T1, T2, T3>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T1 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T2 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T3 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T4 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T1 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T2 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T3 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T4 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T5 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    /// <typeparam name="T10">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }
        private T10 v10;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T10 value)
        {
            Type = typeof(T10);
            v10 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(T10 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T10 value)
        {
            if (Type == typeof(T10))
            {
                value = v10;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T10(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> union)
        {
            if (union.Match(out T10 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T10 value)
        {
            Type = typeof(T10);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }
            else if (Type == typeof(T10))
            {
                return v10;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    /// <typeparam name="T10">A possible type of the union.</typeparam>
    /// <typeparam name="T11">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }
        private T10 v10;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T10 value)
        {
            Type = typeof(T10);
            v10 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T10 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T10 value)
        {
            if (Type == typeof(T10))
            {
                value = v10;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T10(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T10 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T10 value)
        {
            Type = typeof(T10);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = value;
        }
        private T11 v11;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T11 value)
        {
            Type = typeof(T11);
            v11 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(T11 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T11 value)
        {
            if (Type == typeof(T11))
            {
                value = v11;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T11(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> union)
        {
            if (union.Match(out T11 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T11 value)
        {
            Type = typeof(T11);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }
            else if (Type == typeof(T10))
            {
                return v10;
            }
            else if (Type == typeof(T11))
            {
                return v11;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    /// <typeparam name="T10">A possible type of the union.</typeparam>
    /// <typeparam name="T11">A possible type of the union.</typeparam>
    /// <typeparam name="T12">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }
        private T10 v10;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T10 value)
        {
            Type = typeof(T10);
            v10 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T10 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T10 value)
        {
            if (Type == typeof(T10))
            {
                value = v10;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T10(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T10 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T10 value)
        {
            Type = typeof(T10);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = value;
        }
        private T11 v11;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T11 value)
        {
            Type = typeof(T11);
            v11 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T11 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T11 value)
        {
            if (Type == typeof(T11))
            {
                value = v11;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T11(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T11 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T11 value)
        {
            Type = typeof(T11);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = value;
        }
        private T12 v12;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T12 value)
        {
            Type = typeof(T12);
            v12 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(T12 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T12 value)
        {
            if (Type == typeof(T12))
            {
                value = v12;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T12(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> union)
        {
            if (union.Match(out T12 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T12 value)
        {
            Type = typeof(T12);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }
            else if (Type == typeof(T10))
            {
                return v10;
            }
            else if (Type == typeof(T11))
            {
                return v11;
            }
            else if (Type == typeof(T12))
            {
                return v12;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    /// <typeparam name="T10">A possible type of the union.</typeparam>
    /// <typeparam name="T11">A possible type of the union.</typeparam>
    /// <typeparam name="T12">A possible type of the union.</typeparam>
    /// <typeparam name="T13">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }
        private T10 v10;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T10 value)
        {
            Type = typeof(T10);
            v10 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T10 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T10 value)
        {
            if (Type == typeof(T10))
            {
                value = v10;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T10(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T10 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T10 value)
        {
            Type = typeof(T10);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = value;
        }
        private T11 v11;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T11 value)
        {
            Type = typeof(T11);
            v11 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T11 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T11 value)
        {
            if (Type == typeof(T11))
            {
                value = v11;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T11(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T11 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T11 value)
        {
            Type = typeof(T11);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = value;
        }
        private T12 v12;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T12 value)
        {
            Type = typeof(T12);
            v12 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T12 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T12 value)
        {
            if (Type == typeof(T12))
            {
                value = v12;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T12(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T12 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T12 value)
        {
            Type = typeof(T12);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = value;
        }
        private T13 v13;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T13 value)
        {
            Type = typeof(T13);
            v13 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(T13 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T13 value)
        {
            if (Type == typeof(T13))
            {
                value = v13;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T13(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> union)
        {
            if (union.Match(out T13 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T13 value)
        {
            Type = typeof(T13);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }
            else if (Type == typeof(T10))
            {
                return v10;
            }
            else if (Type == typeof(T11))
            {
                return v11;
            }
            else if (Type == typeof(T12))
            {
                return v12;
            }
            else if (Type == typeof(T13))
            {
                return v13;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    /// <typeparam name="T10">A possible type of the union.</typeparam>
    /// <typeparam name="T11">A possible type of the union.</typeparam>
    /// <typeparam name="T12">A possible type of the union.</typeparam>
    /// <typeparam name="T13">A possible type of the union.</typeparam>
    /// <typeparam name="T14">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }
        private T10 v10;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T10 value)
        {
            Type = typeof(T10);
            v10 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T10 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T10 value)
        {
            if (Type == typeof(T10))
            {
                value = v10;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T10(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T10 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T10 value)
        {
            Type = typeof(T10);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = value;
        }
        private T11 v11;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T11 value)
        {
            Type = typeof(T11);
            v11 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T11 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T11 value)
        {
            if (Type == typeof(T11))
            {
                value = v11;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T11(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T11 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T11 value)
        {
            Type = typeof(T11);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = value;
        }
        private T12 v12;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T12 value)
        {
            Type = typeof(T12);
            v12 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T12 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T12 value)
        {
            if (Type == typeof(T12))
            {
                value = v12;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T12(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T12 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T12 value)
        {
            Type = typeof(T12);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = value;
        }
        private T13 v13;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T13 value)
        {
            Type = typeof(T13);
            v13 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T13 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T13 value)
        {
            if (Type == typeof(T13))
            {
                value = v13;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T13(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T13 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T13 value)
        {
            Type = typeof(T13);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = value;
        }
        private T14 v14;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T14 value)
        {
            Type = typeof(T14);
            v14 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(T14 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T14 value)
        {
            if (Type == typeof(T14))
            {
                value = v14;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T14(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> union)
        {
            if (union.Match(out T14 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T14 value)
        {
            Type = typeof(T14);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = default;
            v14 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }
            else if (Type == typeof(T10))
            {
                return v10;
            }
            else if (Type == typeof(T11))
            {
                return v11;
            }
            else if (Type == typeof(T12))
            {
                return v12;
            }
            else if (Type == typeof(T13))
            {
                return v13;
            }
            else if (Type == typeof(T14))
            {
                return v14;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    /// <typeparam name="T10">A possible type of the union.</typeparam>
    /// <typeparam name="T11">A possible type of the union.</typeparam>
    /// <typeparam name="T12">A possible type of the union.</typeparam>
    /// <typeparam name="T13">A possible type of the union.</typeparam>
    /// <typeparam name="T14">A possible type of the union.</typeparam>
    /// <typeparam name="T15">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }
        private T10 v10;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T10 value)
        {
            Type = typeof(T10);
            v10 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T10 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T10 value)
        {
            if (Type == typeof(T10))
            {
                value = v10;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T10(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T10 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T10 value)
        {
            Type = typeof(T10);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = value;
        }
        private T11 v11;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T11 value)
        {
            Type = typeof(T11);
            v11 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T11 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T11 value)
        {
            if (Type == typeof(T11))
            {
                value = v11;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T11(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T11 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T11 value)
        {
            Type = typeof(T11);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = value;
        }
        private T12 v12;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T12 value)
        {
            Type = typeof(T12);
            v12 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T12 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T12 value)
        {
            if (Type == typeof(T12))
            {
                value = v12;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T12(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T12 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T12 value)
        {
            Type = typeof(T12);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = value;
        }
        private T13 v13;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T13 value)
        {
            Type = typeof(T13);
            v13 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T13 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T13 value)
        {
            if (Type == typeof(T13))
            {
                value = v13;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T13(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T13 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T13 value)
        {
            Type = typeof(T13);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = value;
        }
        private T14 v14;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T14 value)
        {
            Type = typeof(T14);
            v14 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T14 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T14 value)
        {
            if (Type == typeof(T14))
            {
                value = v14;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T14(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T14 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T14 value)
        {
            Type = typeof(T14);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = default;
            v14 = value;
        }
        private T15 v15;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T15 value)
        {
            Type = typeof(T15);
            v15 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(T15 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T15 value)
        {
            if (Type == typeof(T15))
            {
                value = v15;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T15(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> union)
        {
            if (union.Match(out T15 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T15 value)
        {
            Type = typeof(T15);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = default;
            v14 = default;
            v15 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }
            else if (Type == typeof(T10))
            {
                return v10;
            }
            else if (Type == typeof(T11))
            {
                return v11;
            }
            else if (Type == typeof(T12))
            {
                return v12;
            }
            else if (Type == typeof(T13))
            {
                return v13;
            }
            else if (Type == typeof(T14))
            {
                return v14;
            }
            else if (Type == typeof(T15))
            {
                return v15;
            }

            return null;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    /// <typeparam name="T9">A possible type of the union.</typeparam>
    /// <typeparam name="T10">A possible type of the union.</typeparam>
    /// <typeparam name="T11">A possible type of the union.</typeparam>
    /// <typeparam name="T12">A possible type of the union.</typeparam>
    /// <typeparam name="T13">A possible type of the union.</typeparam>
    /// <typeparam name="T14">A possible type of the union.</typeparam>
    /// <typeparam name="T15">A possible type of the union.</typeparam>
    /// <typeparam name="T16">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T1 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T2 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T3 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T4 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T5 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T6 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T7 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T8 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }
        private T9 v9;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T9 value)
        {
            Type = typeof(T9);
            v9 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T9 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T9 value)
        {
            if (Type == typeof(T9))
            {
                value = v9;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T9(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T9 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T9 value)
        {
            Type = typeof(T9);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = value;
        }
        private T10 v10;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T10 value)
        {
            Type = typeof(T10);
            v10 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T10 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T10 value)
        {
            if (Type == typeof(T10))
            {
                value = v10;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T10(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T10 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T10 value)
        {
            Type = typeof(T10);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = value;
        }
        private T11 v11;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T11 value)
        {
            Type = typeof(T11);
            v11 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T11 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T11 value)
        {
            if (Type == typeof(T11))
            {
                value = v11;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T11(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T11 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T11 value)
        {
            Type = typeof(T11);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = value;
        }
        private T12 v12;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T12 value)
        {
            Type = typeof(T12);
            v12 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T12 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T12 value)
        {
            if (Type == typeof(T12))
            {
                value = v12;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T12(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T12 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T12 value)
        {
            Type = typeof(T12);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = value;
        }
        private T13 v13;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T13 value)
        {
            Type = typeof(T13);
            v13 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T13 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T13 value)
        {
            if (Type == typeof(T13))
            {
                value = v13;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T13(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T13 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T13 value)
        {
            Type = typeof(T13);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = value;
        }
        private T14 v14;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T14 value)
        {
            Type = typeof(T14);
            v14 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T14 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T14 value)
        {
            if (Type == typeof(T14))
            {
                value = v14;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T14(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T14 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T14 value)
        {
            Type = typeof(T14);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = default;
            v14 = value;
        }
        private T15 v15;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T15 value)
        {
            Type = typeof(T15);
            v15 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T15 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T15 value)
        {
            if (Type == typeof(T15))
            {
                value = v15;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T15(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T15 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T15 value)
        {
            Type = typeof(T15);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = default;
            v14 = default;
            v15 = value;
        }
        private T16 v16;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T16 value)
        {
            Type = typeof(T16);
            v16 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(T16 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T16 value)
        {
            if (Type == typeof(T16))
            {
                value = v16;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T16(Union<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> union)
        {
            if (union.Match(out T16 value))
            {
                return value;
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T16 value)
        {
            Type = typeof(T16);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = default;
            v9 = default;
            v10 = default;
            v11 = default;
            v12 = default;
            v13 = default;
            v14 = default;
            v15 = default;
            v16 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T1))
            {
                return v1;
            }
            else if (Type == typeof(T2))
            {
                return v2;
            }
            else if (Type == typeof(T3))
            {
                return v3;
            }
            else if (Type == typeof(T4))
            {
                return v4;
            }
            else if (Type == typeof(T5))
            {
                return v5;
            }
            else if (Type == typeof(T6))
            {
                return v6;
            }
            else if (Type == typeof(T7))
            {
                return v7;
            }
            else if (Type == typeof(T8))
            {
                return v8;
            }
            else if (Type == typeof(T9))
            {
                return v9;
            }
            else if (Type == typeof(T10))
            {
                return v10;
            }
            else if (Type == typeof(T11))
            {
                return v11;
            }
            else if (Type == typeof(T12))
            {
                return v12;
            }
            else if (Type == typeof(T13))
            {
                return v13;
            }
            else if (Type == typeof(T14))
            {
                return v14;
            }
            else if (Type == typeof(T15))
            {
                return v15;
            }
            else if (Type == typeof(T16))
            {
                return v16;
            }

            return null;
        }
    }
}
