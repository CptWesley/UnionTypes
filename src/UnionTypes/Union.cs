// <auto-generated>
using System;

namespace UnionTypes
{
    /// <summary>
    /// Base class for all union classes.
    /// </summary>
    public abstract class Union
    {
        /// <summary>
        /// Gets or sets the type of the value in the union.
        /// </summary>
        public Type Type { get; protected set; }

        /// <summary>
        /// Gets the possible types in the union.
        /// </summary>
        public abstract Type[] Types { get; }

        /// <summary>
        /// Gets the value stored in the union.
        /// </summary>
        /// <returns>The value stored in the union. Null if no value was found.</returns>
        public abstract object GetValue();
    }

    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    public class Union<T1, T2> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2>(T1 value)
            => new Union<T1, T2>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2> union)
        {
            if (union.Match(out T1 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2>(T2 value)
            => new Union<T1, T2>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2> union)
        {
            if (union.Match(out T2 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1)) return v1;
            if (Type == typeof(T2)) return v2;
            return null;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is Union<T1, T2> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(Union<T1, T2> other)
        {
            if (Type == other.Type)
            {
                if (Type == typeof(T1)) return (v1 == null && other.v1 == null) || v1.Equals(other.v1);
                if (Type == typeof(T2)) return (v2 == null && other.v2 == null) || v2.Equals(other.v2);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

            if (Type == typeof(T1)) return v1 == null ? baseHash * 3 : v1.GetHashCode() * baseHash * 3;
            if (Type == typeof(T2)) return v2 == null ? baseHash * 4 : v2.GetHashCode() * baseHash * 4;
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            if (Type == typeof(T1)) return v1 == null ? string.Empty : v1.ToString();
            if (Type == typeof(T2)) return v2 == null ? string.Empty : v2.ToString();
            return string.Empty;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3>(T1 value)
            => new Union<T1, T2, T3>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3> union)
        {
            if (union.Match(out T1 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3>(T2 value)
            => new Union<T1, T2, T3>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3> union)
        {
            if (union.Match(out T2 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3>(T3 value)
            => new Union<T1, T2, T3>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3> union)
        {
            if (union.Match(out T3 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1)) return v1;
            if (Type == typeof(T2)) return v2;
            if (Type == typeof(T3)) return v3;
            return null;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is Union<T1, T2, T3> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(Union<T1, T2, T3> other)
        {
            if (Type == other.Type)
            {
                if (Type == typeof(T1)) return (v1 == null && other.v1 == null) || v1.Equals(other.v1);
                if (Type == typeof(T2)) return (v2 == null && other.v2 == null) || v2.Equals(other.v2);
                if (Type == typeof(T3)) return (v3 == null && other.v3 == null) || v3.Equals(other.v3);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

            if (Type == typeof(T1)) return v1 == null ? baseHash * 3 : v1.GetHashCode() * baseHash * 3;
            if (Type == typeof(T2)) return v2 == null ? baseHash * 4 : v2.GetHashCode() * baseHash * 4;
            if (Type == typeof(T3)) return v3 == null ? baseHash * 5 : v3.GetHashCode() * baseHash * 5;
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            if (Type == typeof(T1)) return v1 == null ? string.Empty : v1.ToString();
            if (Type == typeof(T2)) return v2 == null ? string.Empty : v2.ToString();
            if (Type == typeof(T3)) return v3 == null ? string.Empty : v3.ToString();
            return string.Empty;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T1 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T1 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T2 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T2 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T3 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T3 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4>(T4 value)
            => new Union<T1, T2, T3, T4>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4> union)
        {
            if (union.Match(out T4 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1)) return v1;
            if (Type == typeof(T2)) return v2;
            if (Type == typeof(T3)) return v3;
            if (Type == typeof(T4)) return v4;
            return null;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is Union<T1, T2, T3, T4> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(Union<T1, T2, T3, T4> other)
        {
            if (Type == other.Type)
            {
                if (Type == typeof(T1)) return (v1 == null && other.v1 == null) || v1.Equals(other.v1);
                if (Type == typeof(T2)) return (v2 == null && other.v2 == null) || v2.Equals(other.v2);
                if (Type == typeof(T3)) return (v3 == null && other.v3 == null) || v3.Equals(other.v3);
                if (Type == typeof(T4)) return (v4 == null && other.v4 == null) || v4.Equals(other.v4);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

            if (Type == typeof(T1)) return v1 == null ? baseHash * 3 : v1.GetHashCode() * baseHash * 3;
            if (Type == typeof(T2)) return v2 == null ? baseHash * 4 : v2.GetHashCode() * baseHash * 4;
            if (Type == typeof(T3)) return v3 == null ? baseHash * 5 : v3.GetHashCode() * baseHash * 5;
            if (Type == typeof(T4)) return v4 == null ? baseHash * 6 : v4.GetHashCode() * baseHash * 6;
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            if (Type == typeof(T1)) return v1 == null ? string.Empty : v1.ToString();
            if (Type == typeof(T2)) return v2 == null ? string.Empty : v2.ToString();
            if (Type == typeof(T3)) return v3 == null ? string.Empty : v3.ToString();
            if (Type == typeof(T4)) return v4 == null ? string.Empty : v4.ToString();
            return string.Empty;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T1 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T1 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T2 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T2 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T3 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T3 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T4 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T4 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5>(T5 value)
            => new Union<T1, T2, T3, T4, T5>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5> union)
        {
            if (union.Match(out T5 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1)) return v1;
            if (Type == typeof(T2)) return v2;
            if (Type == typeof(T3)) return v3;
            if (Type == typeof(T4)) return v4;
            if (Type == typeof(T5)) return v5;
            return null;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is Union<T1, T2, T3, T4, T5> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(Union<T1, T2, T3, T4, T5> other)
        {
            if (Type == other.Type)
            {
                if (Type == typeof(T1)) return (v1 == null && other.v1 == null) || v1.Equals(other.v1);
                if (Type == typeof(T2)) return (v2 == null && other.v2 == null) || v2.Equals(other.v2);
                if (Type == typeof(T3)) return (v3 == null && other.v3 == null) || v3.Equals(other.v3);
                if (Type == typeof(T4)) return (v4 == null && other.v4 == null) || v4.Equals(other.v4);
                if (Type == typeof(T5)) return (v5 == null && other.v5 == null) || v5.Equals(other.v5);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

            if (Type == typeof(T1)) return v1 == null ? baseHash * 3 : v1.GetHashCode() * baseHash * 3;
            if (Type == typeof(T2)) return v2 == null ? baseHash * 4 : v2.GetHashCode() * baseHash * 4;
            if (Type == typeof(T3)) return v3 == null ? baseHash * 5 : v3.GetHashCode() * baseHash * 5;
            if (Type == typeof(T4)) return v4 == null ? baseHash * 6 : v4.GetHashCode() * baseHash * 6;
            if (Type == typeof(T5)) return v5 == null ? baseHash * 7 : v5.GetHashCode() * baseHash * 7;
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            if (Type == typeof(T1)) return v1 == null ? string.Empty : v1.ToString();
            if (Type == typeof(T2)) return v2 == null ? string.Empty : v2.ToString();
            if (Type == typeof(T3)) return v3 == null ? string.Empty : v3.ToString();
            if (Type == typeof(T4)) return v4 == null ? string.Empty : v4.ToString();
            if (Type == typeof(T5)) return v5 == null ? string.Empty : v5.ToString();
            return string.Empty;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T1 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T2 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T3 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T4 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T5 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6> union)
        {
            if (union.Match(out T6 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1)) return v1;
            if (Type == typeof(T2)) return v2;
            if (Type == typeof(T3)) return v3;
            if (Type == typeof(T4)) return v4;
            if (Type == typeof(T5)) return v5;
            if (Type == typeof(T6)) return v6;
            return null;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is Union<T1, T2, T3, T4, T5, T6> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(Union<T1, T2, T3, T4, T5, T6> other)
        {
            if (Type == other.Type)
            {
                if (Type == typeof(T1)) return (v1 == null && other.v1 == null) || v1.Equals(other.v1);
                if (Type == typeof(T2)) return (v2 == null && other.v2 == null) || v2.Equals(other.v2);
                if (Type == typeof(T3)) return (v3 == null && other.v3 == null) || v3.Equals(other.v3);
                if (Type == typeof(T4)) return (v4 == null && other.v4 == null) || v4.Equals(other.v4);
                if (Type == typeof(T5)) return (v5 == null && other.v5 == null) || v5.Equals(other.v5);
                if (Type == typeof(T6)) return (v6 == null && other.v6 == null) || v6.Equals(other.v6);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

            if (Type == typeof(T1)) return v1 == null ? baseHash * 3 : v1.GetHashCode() * baseHash * 3;
            if (Type == typeof(T2)) return v2 == null ? baseHash * 4 : v2.GetHashCode() * baseHash * 4;
            if (Type == typeof(T3)) return v3 == null ? baseHash * 5 : v3.GetHashCode() * baseHash * 5;
            if (Type == typeof(T4)) return v4 == null ? baseHash * 6 : v4.GetHashCode() * baseHash * 6;
            if (Type == typeof(T5)) return v5 == null ? baseHash * 7 : v5.GetHashCode() * baseHash * 7;
            if (Type == typeof(T6)) return v6 == null ? baseHash * 8 : v6.GetHashCode() * baseHash * 8;
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            if (Type == typeof(T1)) return v1 == null ? string.Empty : v1.ToString();
            if (Type == typeof(T2)) return v2 == null ? string.Empty : v2.ToString();
            if (Type == typeof(T3)) return v3 == null ? string.Empty : v3.ToString();
            if (Type == typeof(T4)) return v4 == null ? string.Empty : v4.ToString();
            if (Type == typeof(T5)) return v5 == null ? string.Empty : v5.ToString();
            if (Type == typeof(T6)) return v6 == null ? string.Empty : v6.ToString();
            return string.Empty;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T1 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T2 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T3 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T4 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T5 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T6 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7> union)
        {
            if (union.Match(out T7 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1)) return v1;
            if (Type == typeof(T2)) return v2;
            if (Type == typeof(T3)) return v3;
            if (Type == typeof(T4)) return v4;
            if (Type == typeof(T5)) return v5;
            if (Type == typeof(T6)) return v6;
            if (Type == typeof(T7)) return v7;
            return null;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is Union<T1, T2, T3, T4, T5, T6, T7> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(Union<T1, T2, T3, T4, T5, T6, T7> other)
        {
            if (Type == other.Type)
            {
                if (Type == typeof(T1)) return (v1 == null && other.v1 == null) || v1.Equals(other.v1);
                if (Type == typeof(T2)) return (v2 == null && other.v2 == null) || v2.Equals(other.v2);
                if (Type == typeof(T3)) return (v3 == null && other.v3 == null) || v3.Equals(other.v3);
                if (Type == typeof(T4)) return (v4 == null && other.v4 == null) || v4.Equals(other.v4);
                if (Type == typeof(T5)) return (v5 == null && other.v5 == null) || v5.Equals(other.v5);
                if (Type == typeof(T6)) return (v6 == null && other.v6 == null) || v6.Equals(other.v6);
                if (Type == typeof(T7)) return (v7 == null && other.v7 == null) || v7.Equals(other.v7);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

            if (Type == typeof(T1)) return v1 == null ? baseHash * 3 : v1.GetHashCode() * baseHash * 3;
            if (Type == typeof(T2)) return v2 == null ? baseHash * 4 : v2.GetHashCode() * baseHash * 4;
            if (Type == typeof(T3)) return v3 == null ? baseHash * 5 : v3.GetHashCode() * baseHash * 5;
            if (Type == typeof(T4)) return v4 == null ? baseHash * 6 : v4.GetHashCode() * baseHash * 6;
            if (Type == typeof(T5)) return v5 == null ? baseHash * 7 : v5.GetHashCode() * baseHash * 7;
            if (Type == typeof(T6)) return v6 == null ? baseHash * 8 : v6.GetHashCode() * baseHash * 8;
            if (Type == typeof(T7)) return v7 == null ? baseHash * 9 : v7.GetHashCode() * baseHash * 9;
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            if (Type == typeof(T1)) return v1 == null ? string.Empty : v1.ToString();
            if (Type == typeof(T2)) return v2 == null ? string.Empty : v2.ToString();
            if (Type == typeof(T3)) return v3 == null ? string.Empty : v3.ToString();
            if (Type == typeof(T4)) return v4 == null ? string.Empty : v4.ToString();
            if (Type == typeof(T5)) return v5 == null ? string.Empty : v5.ToString();
            if (Type == typeof(T6)) return v6 == null ? string.Empty : v6.ToString();
            if (Type == typeof(T7)) return v7 == null ? string.Empty : v7.ToString();
            return string.Empty;
        }
    }
    /// <summary>
    /// A union type.
    /// </summary>
    /// <typeparam name="T1">A possible type of the union.</typeparam>
    /// <typeparam name="T2">A possible type of the union.</typeparam>
    /// <typeparam name="T3">A possible type of the union.</typeparam>
    /// <typeparam name="T4">A possible type of the union.</typeparam>
    /// <typeparam name="T5">A possible type of the union.</typeparam>
    /// <typeparam name="T6">A possible type of the union.</typeparam>
    /// <typeparam name="T7">A possible type of the union.</typeparam>
    /// <typeparam name="T8">A possible type of the union.</typeparam>
    public class Union<T1, T2, T3, T4, T5, T6, T7, T8> : Union
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        public Union()
        {
        }

        /// <inheritdoc/>
        public override Type[] Types => new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8) };

        private T1 v1;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T1 value)
        {
            if (Type == typeof(T1))
            {
                value = v1;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T1(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T1 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T1 value)
        {
            Type = typeof(T1);
            v1 = value;
        }
        private T2 v2;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T2 value)
        {
            Type = typeof(T2);
            v2 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T2 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T2 value)
        {
            if (Type == typeof(T2))
            {
                value = v2;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T2(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T2 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T2 value)
        {
            Type = typeof(T2);
            v1 = default;
            v2 = value;
        }
        private T3 v3;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T3 value)
        {
            Type = typeof(T3);
            v3 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T3 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T3 value)
        {
            if (Type == typeof(T3))
            {
                value = v3;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T3(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T3 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T3 value)
        {
            Type = typeof(T3);
            v1 = default;
            v2 = default;
            v3 = value;
        }
        private T4 v4;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T4 value)
        {
            Type = typeof(T4);
            v4 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T4 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T4 value)
        {
            if (Type == typeof(T4))
            {
                value = v4;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T4(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T4 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T4 value)
        {
            Type = typeof(T4);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = value;
        }
        private T5 v5;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T5 value)
        {
            Type = typeof(T5);
            v5 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T5 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T5 value)
        {
            if (Type == typeof(T5))
            {
                value = v5;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T5(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T5 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T5 value)
        {
            Type = typeof(T5);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = value;
        }
        private T6 v6;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T6 value)
        {
            Type = typeof(T6);
            v6 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T6 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T6 value)
        {
            if (Type == typeof(T6))
            {
                value = v6;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T6(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T6 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T6 value)
        {
            Type = typeof(T6);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = value;
        }
        private T7 v7;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T7 value)
        {
            Type = typeof(T7);
            v7 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T7 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T7 value)
        {
            if (Type == typeof(T7))
            {
                value = v7;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T7(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T7 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T7 value)
        {
            Type = typeof(T7);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = value;
        }
        private T8 v8;

        /// <summary>
        /// Initializes a new instance of the <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> class.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        public Union(T8 value)
        {
            Type = typeof(T8);
            v8 = value;
        }

        /// <summary>
        /// Performs an implicit conversion from one of it's union types to to <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/>.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Union<T1, T2, T3, T4, T5, T6, T7, T8>(T8 value)
            => new Union<T1, T2, T3, T4, T5, T6, T7, T8>(value);

        /// <summary>
        /// Tries to retrieve the value of the given type from the union.
        /// </summary>
        /// <param name="value">The value in the union.</param>
        /// <returns>True if the union contained a value of that type, false otherwise.</returns>
        public bool Match(out T8 value)
        {
            if (Type == typeof(T8))
            {
                value = v8;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Performs an explicit conversion from <see cref="Union{T1, T2, T3, T4, T5, T6, T7, T8}"/> to a contained type.
        /// </summary>
        /// <param name="union">The union.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        /// <exception cref="InvalidCastException">Thrown when the type of the value contained in the union is not correct./></exception>
        public static explicit operator T8(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
        {
            if (union.Match(out T8 value)) return value;
            throw new InvalidCastException();
        }

        /// <summary>
        /// Sets the value in the union to a new value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetValue(T8 value)
        {
            Type = typeof(T8);
            v1 = default;
            v2 = default;
            v3 = default;
            v4 = default;
            v5 = default;
            v6 = default;
            v7 = default;
            v8 = value;
        }

        /// <inheritdoc/>
        public override object GetValue()
        {
            if (Type == typeof(T1)) return v1;
            if (Type == typeof(T2)) return v2;
            if (Type == typeof(T3)) return v3;
            if (Type == typeof(T4)) return v4;
            if (Type == typeof(T5)) return v5;
            if (Type == typeof(T6)) return v6;
            if (Type == typeof(T7)) return v7;
            if (Type == typeof(T8)) return v8;
            return null;
        }

        /// <inheritdoc/>
        public override bool Equals(object obj)
        {
            if (obj is Union<T1, T2, T3, T4, T5, T6, T7, T8> union) return Equals(union);
            return false;
        }

        /// <summary>
        /// Compares if another union of the same type is equal to this union.
        /// </summary>
        /// <param name="other">The union to compare to.</param>
        /// <returns>True if the union is equal, false otherwise.</returns>
        public bool Equals(Union<T1, T2, T3, T4, T5, T6, T7, T8> other)
        {
            if (Type == other.Type)
            {
                if (Type == typeof(T1)) return (v1 == null && other.v1 == null) || v1.Equals(other.v1);
                if (Type == typeof(T2)) return (v2 == null && other.v2 == null) || v2.Equals(other.v2);
                if (Type == typeof(T3)) return (v3 == null && other.v3 == null) || v3.Equals(other.v3);
                if (Type == typeof(T4)) return (v4 == null && other.v4 == null) || v4.Equals(other.v4);
                if (Type == typeof(T5)) return (v5 == null && other.v5 == null) || v5.Equals(other.v5);
                if (Type == typeof(T6)) return (v6 == null && other.v6 == null) || v6.Equals(other.v6);
                if (Type == typeof(T7)) return (v7 == null && other.v7 == null) || v7.Equals(other.v7);
                if (Type == typeof(T8)) return (v8 == null && other.v8 == null) || v8.Equals(other.v8);
            }

            return false;
        }

        /// <inheritdoc/>
        public override int GetHashCode()
        {
            int baseHash = GetType().GetHashCode();

            if (Type == typeof(T1)) return v1 == null ? baseHash * 3 : v1.GetHashCode() * baseHash * 3;
            if (Type == typeof(T2)) return v2 == null ? baseHash * 4 : v2.GetHashCode() * baseHash * 4;
            if (Type == typeof(T3)) return v3 == null ? baseHash * 5 : v3.GetHashCode() * baseHash * 5;
            if (Type == typeof(T4)) return v4 == null ? baseHash * 6 : v4.GetHashCode() * baseHash * 6;
            if (Type == typeof(T5)) return v5 == null ? baseHash * 7 : v5.GetHashCode() * baseHash * 7;
            if (Type == typeof(T6)) return v6 == null ? baseHash * 8 : v6.GetHashCode() * baseHash * 8;
            if (Type == typeof(T7)) return v7 == null ? baseHash * 9 : v7.GetHashCode() * baseHash * 9;
            if (Type == typeof(T8)) return v8 == null ? baseHash * 10 : v8.GetHashCode() * baseHash * 10;
            return baseHash * 2;
        }

        /// <inheritdoc/>
        public override string ToString()
        {
            if (Type == typeof(T1)) return v1 == null ? string.Empty : v1.ToString();
            if (Type == typeof(T2)) return v2 == null ? string.Empty : v2.ToString();
            if (Type == typeof(T3)) return v3 == null ? string.Empty : v3.ToString();
            if (Type == typeof(T4)) return v4 == null ? string.Empty : v4.ToString();
            if (Type == typeof(T5)) return v5 == null ? string.Empty : v5.ToString();
            if (Type == typeof(T6)) return v6 == null ? string.Empty : v6.ToString();
            if (Type == typeof(T7)) return v7 == null ? string.Empty : v7.ToString();
            if (Type == typeof(T8)) return v8 == null ? string.Empty : v8.ToString();
            return string.Empty;
        }
    }
}
